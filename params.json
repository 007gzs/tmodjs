{"name":"进击！前端模板工程化","tagline":"基于 TmodJS 前端模板工程化解决方案","body":"##\t前言\r\n\r\n现在，越来越多的前端项目采用了单页或者混合式的架构，在这种架构中后端只负责吐出 JSON 数据，前端异步来渲染 HTML，前端模板被大量使用，与此同时也将引发开发维护与发布优化的问题。为了解决这些问题，我们曾经开发了工具 TmodJS（原名 atc），试图通过本地自动化工具让端模板走上工程化之路。很高兴这个工具经过长达 8 个月的磨砺后，它从一个简陋的工具变成如今的“利器”，已经成功为公司内多个项目服务。现在我将对前端模板工程化的一些思考与总结分享出来，希望能够帮助到大家。\r\n\r\n在主题开始之前，先简单总结下前端模板技术的发展：\r\n\r\n##\t手工拼接字符串时代\r\n\r\n早期，开发人员都是直接在 js 文件中采用最原始的方式直接拼接 HTML 字符串：\r\n\r\n\tvar html = '';\r\n\tfor (var i = 0, users = data.users; i < users.length; i ++) {\r\n\t\thtml += '<li><a href=\"'\r\n\t\t+ users[i].url\r\n\t\t+ '\">'\r\n\t\t+ users[i].name\r\n\t\t+ '</a></li>';\r\n\t}\r\n\t//...\r\n\r\n这种方式刚开始在一两个简单的页面中还是比较灵活的，但弊端也十分明显：UI 与逻辑代码混杂在一起，阅读起来会非常吃力。一旦随着业务复杂起来，或者多人维护的情况下，几乎会失控。\r\n\r\n##\t前端模板引擎时代\r\n\r\n受 jquery 作者的 [tmpl](http://ejohn.org/blog/javascript-micro-templating/) 模板引擎影响，从 09 年开始到现在前端模板引擎出现了百花齐放，一条前端模板类似这样：\r\n\r\n\t<script id=\"user_tmpl\" type=\"text/html\">\r\n\t{{each users as value}}\r\n\t\t<li>\r\n\t\t\t<a href=\"{{value.url}}\">{{value.name}}</a>\r\n\t\t</li>\r\n\t{{/each}}\r\n\t</script>\r\n\r\n它使用一个特殊的``<script type=\"text/html\"></script>``标签来存放模板（由于浏览器不支持这种类型的声明，它存放的代码不会当作 js 运行，代码也不会被显示出来）。使用模板引擎渲染模板的示例：\r\n\r\n\tvar html = tmpl('user_tmpl', data);\r\n\tdocument.getElementById('content').innerHTML = html;\r\n\t\r\n通过前端模板引擎将 UI 分离后，模板的书写与修改就变得简单多了，多人协作的问题已经得到解决，因此前端模板引擎它也成了前端技术体系中中一个十分基础的类库。但是，这种方式规模化后其弊端也随之而来：\r\n\r\n###\t页面内嵌模板之弊端\r\n\r\n####\t1. 开发调试\r\n\r\n每次修改前端模板需要改动页面的代码，有时候存放模板的页面又依赖服务器，这使得我们无法使用使用类似 Fiddler 的工具将页面映射到本地进行开发，从而不得不传到服务器或者自己搭建本地服务器环境，以至于开发维护过程异常繁琐。\r\n\r\n####\t2. 体积优化\r\n\r\n动态页面与前端模板结合的架构中，不利于浏览器缓存，通常在单页应用中，页面页面会堆砌着大量的``<script type=\"text/html\"></script>``标签，每次进入应用都需要重新加载模板代码，造成不必要的网络开销。\r\n\r\n####\t3.\t模板复用\r\n\r\n比如类似“好友选择器”这样的公用模块，页面内嵌模板满足不了模板复用的需求。\r\n\r\n以上问题本质都是因为模板堆砌在一个文件中造成的，于是越来越的项目开始将前端模板从页面中迁移出来，目前主要有两种方式：\r\n\r\n###\t优化：外置模板\r\n\r\n####\t1. Ajax 或 Iframe 远程拉取方案\r\n\r\n通过 Ajax 或 Iframe 加载远程模板，然后再使用模板引擎解析，这种方式的弊端相当明显：\r\n\r\n1.\t无法跨域部署。这是由浏览器同源策略限制的，导致模板无法部署到 CDN 网络。\r\n2.\t复杂度比较高，难以接入主流的自动化部署、优化工具。\r\n\r\n####\t2. 在 JS 文件中存放模板\r\n\r\n为避免上述加载模板方案无法跨域的致命缺陷，模板存放在 js 文件中又成了最佳实践方式。但是 js 需要对回车符进行转义，会严重影响开发效率：\r\n\r\n\tvar user_tmpl =\r\n\t'<% for (var i = 0; i < users.length; i++) { %>\\\r\n\t\t<li>\\\r\n\t\t\t<a href=\"<%=users[i].url%>\">\\\r\n\t\t\t\t<%=users[i].name%>\\\r\n\t\t\t</a>\\\r\n\t\t</li>\\\r\n\t<% } %>';\r\n\t\r\n###\t模板存放方案优劣总结\r\n\r\n存放方式 | 书写友好 | 跨域问题 | 本地调试 | 代码复用 | 缓存 | 按需加载\r\n------ | ------ | ------ | ------ | ------ | ------ | ------\r\n页面内嵌 | ✓ | ✓ | ✗ | ✗ | ✗ | ✗\r\nAjax 远程加载 | ✓  | ✗| ✓ | ✓ | ✓ | ✓\r\n嵌入 js 文件 | ✗ | ✓ | ✓ | ✓ | ✓ | ✓\r\n\r\n在实践中我们发现：方便优化的模式不利于开发；利于开发的模式不利于优化。\r\n\t\r\n为了解决上述问题，业界出现了一些新的方案，即预编译技术。已知开源引擎 handlebars.js 与 Twitter 的 Hogan.js 支持了预编译，以 handlebars.js 使用为例，先使用 NodeJS 安装它：\r\n\r\n\t$ npm install -g handlebars\r\n\r\n然后提取模板内容（``script`` 标签之间）并保存到一个文件中。在这里我们把它保存为 ``user.tmpl``。运行 ``handlebars`` 命令预编译这个模板文件。\r\n\r\n\t$ handlebars user_tmpl.tmpl -f user.tmpl.js\r\n\r\n编译完成后就可以在前端应用中加载这个脚本，比如这样引入：\r\n\r\n\t<script src=\"user.tmpl.js\"></script>\r\n\t\r\n在逻辑中可以如下访问到模板函数：\r\n\r\n\tvar template = Handlebars.templates[\"user.tmpl\"];\r\n\tvar html = template(data);\r\n\r\n虽然以上介绍的预编译已经支持了半自动化的模板转换，但操作实在是太繁琐。例如一个 web app 单页应用，几百条前端模板是常有的事儿，开发阶段我们会不断的拆分模板，如果每次都需要重新编译这简直会令人抓狂，与此同时大量零散的模板脚本也会引发新的问题，编译后的模板没有提供显式的依赖声明，自动化工具依然难以介入。\r\n\r\n##\t工程化前端模板\r\n\r\nTmodJS 也是基于预编译手段将模板转换成 js。它的模板基于文件系统，完全可以像后端模板一样理解它，开发者根本无需考虑前端各种繁杂的优化问题，这一切全部交给工具自动执行。\r\n\r\n###\t1. 基于文件系统\r\n\r\n在 TmodJS 的规范中，前端模板不再内嵌到页面中，而是使用专门的目录进行组织维护。例如页面头部底部的公用模板可以放在 tpl/public 目录下，新闻栏目的模板可以放在 tpl/news 下面。\r\n\r\n每个模板就是一个 HTML 片段文件，前端开发工程师可直接将设计师的静态页面的 HTML 拷贝过来，无需对换行符转义，开发过程会更友好。\r\n\r\n###\t2. 同步加载接口\r\n\r\n模板加载接口采用同步接口设计，使用路径作为模板的 ID，与源文件一一对应。在浏览器端，TmodJS 的同步接口是通过通过打包合并模板或者使用 AMD、CMD 规范实现，避免了魔鬼般的异步套嵌。\r\n\r\n在默认设置下，TmodJS 会将模板目录所有模板编译后再进行打包，输出一个 template.js 文件，它使用起来类似这样：\r\n\t\r\n\tvar tpl = template('news/index');\r\n\t\r\n模板使用方式：\r\n\r\n\tvar html = tpl(data);\r\n\tdocument.getElementById('content').innerHTML = html;\r\n\r\n输出后的 template.js 称之为模板包（内部名称叫 TemplateJS 格式）这种打包的方式非常适合移动端单页 webApp，输出后的模板包可直接可作为开发阶段与线上运行的文件。\r\n\r\n当然，将所有前端模板都打包在一个文件中不一定适合大型项目，所以 TmodJS 还可以选择不打包合并输出，这样编译后的模板脚本可以交给 GruntJS 等自动化工具进行按需合并。例如腾讯视频前端团队的实践：按照网站栏目建立模板子目录，按栏目进行合并加载。\r\n\r\n除此之外，使用 RequireJS 与 SeaJS 或者 NodeJS 的用户还可以通过配置将每一个模板都编译成与它们更亲近的模块，这时候模板加载的接口是这样的：\r\n\r\n\tvar tpl = requier('tpl/news/index');\r\n\tvar html = tpl(data);\r\n\t//...\r\n\t\r\n这种情况下，接入 RequireJS 优化工具 r.js 或者 SeaJS 的 spm 可以完成精准的按需合并。\r\n\r\n###\t3. 模板内 include 特性支持\r\n\r\n既然是基于文件系统的模板，模板支持``include``语句就是理所当然的事情了，直接通过它来加载公用模板，这样就不需要在业务逻辑中处理模板依赖。\r\n\r\n\t{{include './public/header'}}\r\n\t\r\n如果选择编译为 RequireJS 或 SeaJS 模块，``include``语句最终会被编译成``requier('./xxx')``形式声明依赖。\r\n\r\n###\t4. 实时编译\r\n\r\n通常开发阶段模板会经常被修改，所以 TmodJS 支持监听模板目录的修改，当模板发生修改则会进行增量编译。时间久了甚至可以让人忘记编译过程的存在，完全忘记这是在写前端模板。\r\n\r\n###\t5. 多架构兼容\r\n\r\n一般项目，我们直接采用``<script>``标签载入编译后模板包即可，但是对于使用 RequireJS 或 SeaJS 模块化的项目、甚至是 NodeJS 的项目这将如何处理？\r\n\r\nRequierJS 的模块规范是 AMD，SeaJS 的模块是 CMD，而 NodeJS 的模块规范是 CommonJS —— 这几种规范有很多共同点，很容易进行兼容：\r\n\r\n    // RequireJS && SeaJS\r\n    if (typeof define === 'function') {\r\n        define(function() {\r\n            return template;\r\n        });\r\n\r\n    // NodeJS\r\n    } else if (typeof exports !== 'undefined') {\r\n        module.exports = template;\r\n        \r\n    // <script src=\"...\r\n    } else {\r\n        global.template = template;\r\n    }\r\n   \r\n这短短的几句代码这意味着什么？编译后的模板包几乎无需考虑项目所采取的架构！可以想象：后端直出 HTML 与前端异步加载的混合架构将变得更加容易。\r\n\r\n###\t6. 本地调试\r\n\r\n无论如何模板最终都会转换成 js，亦可使用 Fiddler 将线上模板映射到本地进行开发调试；如果开启实时编译，开发阶段模板修改后只需要刷新浏览器即可预览到效果。\r\n\r\n##\t关于 TmodJS\r\n\r\nTmodJS 原名 atc，之前是腾讯内部公用组件平台的一个开源项目，目前公司已经有 QQ 空间、腾讯视频、微趋势等多个项目在使用。\r\n\r\nTmodJS 编译引擎基于 artTemplate（也是腾讯公用组件平台开源项目），并且原来 artTemplate 项目可以无缝迁移到基于文件系统的模板中来。\r\n\r\n###\t常见问题\r\n\r\n问：TmodJS 需要部署到服务器中吗？\r\n\r\n> 答：不需要，这是本地开发工具，基于 NodeJS 编写是为了实现跨平台。\r\n\r\n问：TmodJS 的编译后模板性能如何？\r\n\r\n> 答：TmodJS 预编译器基于 artTemplate，artTemplate 的执行速度是业界领先的模板引擎之一（仍在不断优化中）。速度测试：<http://aui.github.io/artTemplate/test/test-speed.html>\r\n\r\n问：将模板编译成 js 语句会导致体积增加吗？\r\n\r\n> 答：不会，一般情况下还能起到压缩的效果。例如在腾讯 Microtrend 项目为例：中采用 TmodJS 编译后，原来 Gzip 下 14kb 模板变成 7kb，压缩率高达到 50%，原因：1、模板编译器会压缩 HTML 多余字符 2、编译后代码简练且不再依赖模板引擎。具体请查看编译输出的模板：<http://microtrend.cdc.tencent.com/tpl/dist/template.js>\r\n\r\n问：前端模板能防范 XSS 漏洞么？\r\n\r\n> 答：编译后的 JS 默认会对每一处输出语句进行扫描过滤，模板书写无需考虑安全问题。\r\n\r\n###\t使用 TmodJS 的项目\r\n\r\n*\tQQ 空间\r\n*\t腾讯视频\r\n*\tSpa（迅雷）\r\n*\tMicroTrend（腾讯）\r\n*\tTracker（腾讯）\r\n*\t……\r\n\r\n###\tGithub 主页\r\n\r\n<https://github.com/aui/tmodjs>\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}