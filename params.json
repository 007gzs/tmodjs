{"name":"TmodJS","tagline":"Template Compiler Tools","body":"#\tTmodJS-前端模板管理工具\r\n\r\n######\t像后端一样书写前端模板\r\n\r\n##\t关于 TmodJS\r\n\r\n（原名 atc）\r\n\r\nTmodJS 是一款前端模板管理工具，它使用预编译手段可以让前端模板外置、实现类似后端模板一样按文件与目录组织前端模板，并且模板之间可以使用``include``语句相互包含。\r\n\r\n###\t像后端一样书写前端模板\r\n\r\n相对与前端模板，后端模板有两个优秀的特征：\r\n\r\n1.\t模板按文件与目录组织\r\n2.\t模板之间可以相互引用\r\n\r\n通过 TmodJS 预编译技术让前端模板突破浏览器的文本文件加载限制，支持模板按文件存放，并且支持多层目录组织模板，并且模板之间可通过``include``语句进行复用。\r\n\r\n###\t模板编译输出为 js 文件\r\n\r\n它会将模板编译成 js 文件，编译后的代码体积非常小，不包含模板引擎也无需依赖脚本加载器。因为是预编译，省去前端模板客户端动态编译过程，也能够在移动设备中节省一定的系统资源。\r\n\r\n编译成 js 后，原来字符串模板遇到的跨域加载、异步按需加载已经不是问题，甚至可以接入 GruntJS 等自动化工具进行部署。\r\n\r\n###\t支持接入 AMD 或者 CMD 部署工具\r\n\r\n默认情况下，模板目录将会被打包成 js, 可以直接在页面中使用传统 Script 标签加载，简单且有效。除此之外还可以设置将单个模板文件输出为单个的 AMD 、CMD 异步模块，以便接入它们自动化部署工具进行深度定制化的优化，这样可以实现按需加载、合并等高级的优化手段。\r\n\r\n###\t横跨前后端运行\r\n\r\n支持输出基于 NodeJS 的同步规范模块，前后端可轻松的共用同一套模板。\r\n\r\n###\t动态调试支持\r\n\r\n支持输出调试版本，模板运行中错误可精确到模板源文件所在行。\r\n\r\n###\t即时编译\r\n\r\n支持设置检测模板的修改进行即时编译，这样几乎可以忽略编译过程的存在，模板编写只需要这两个步骤：1、修改模板并保存 2、刷新浏览器预览效果\r\n\r\n##\t安装\r\n\r\n先安装 [NodeJS](http://nodejs.org) 与 npm (最新版 NodeJS 已经附带 npm)，执行：\r\n\r\n\t$ npm install tmodjs -g\r\n\t\r\n> Mac OSX 可能需要管理员权限运行： ``$ sudo npm install tmodjs -g``\r\n\r\n\r\n##\t快速入门\r\n\r\n前提是你能通过上面介绍的安装方式成功安装，按照这个顺序阅读文档大概 7 分钟可上手：\r\n\r\n1. 建立模板目录：TmodJS 是基于目录编译，你至少要给项目建立一个专用的前端模板目录\r\n2. 编写模板：你需要了解 TmodJS 的模板语句，如输出变量、条件判断、循环等\r\n3. 编译模板：编译模板你需要知道如何使用命令，以及一些可能会用到的参数配置\r\n4. 调用模板：如何在项目中加载模板\r\n\r\n###\t一、建立模板目录\r\n\r\nTmodJS 的前端模板不再耦合在业务页面中，而是和后端模板一样有专门的目录管理。目录名称支持英文、数字、下划线。\r\n\r\n###\t二、编写模板\r\n\r\n一个模板对应一个文件，模板后缀可以是``.html``、``.htm``、``.tpl``。\r\n\r\n模板支持输出变量、条件判断、循环、包含子模板，请查看：[模板语法参考](https://github.com/aui/tmodjs/wiki/模板语法)\r\n\r\n###\t三、编译模板\r\n\r\n\t$ tmod [path] [options]\r\n\r\n其中 path 是模板目录。TmodJS 基于目录进行处理。\r\n\r\n####\toptions\r\n            \r\n*\t``-w``或``--watch``设置实时监控模板修改\r\n*\t``-d``或``--debug``输出调试版本\r\n*\t``--charset value``定义模板编码，默认``utf-8``\r\n*\t``--output value``定义输出目录，默认``./build``\r\n*\t``--type value``定义输出模块格式，默认``templatejs``，可选``cmd``、``amd``、``commonjs``\r\n*\t``--version``显示 TmodJS 版本号\r\n*\t``--help``显示帮助信息\r\n\r\n运行完成后，程序会将模板编译成 js 文件。如果你经常需要修改模板，可以开启``-w``参数，让它检测修改自动编译。\r\n\r\n>\t首次运行后，会对模板根目录进行初始化，生成 package.json，也可以编辑它进行更多配置，包括语法、公用辅助方法、压缩选项等，参考[配置](#配置)。\r\n>\t当模板目录初始化后，下次编译模板可以无需输入配置参数，将沿用上一次的参数进行编译（-w 与 -d 除外）。\r\n\r\n###\t四、调用模板\r\n\r\n模板编译后，模板目录会生成 build 子目录，里面包含了所有的模板编译版本。其中 build/template.js 是压缩后的模板包，通常情况下你只需要在页面中引入它就好。例如：\r\n\r\n\t<script src=\"tpl/build/template.js\"></script>\r\n\t\r\n这是默认的加载方式，除此之外还支持 RequireJS、SeaJS、NodeJS 加载。[示例](./test/index.html)\r\n\t\r\n####\t模板接口\r\n\r\n\ttemplate(path, data)\r\n\t\r\npath 参数是**模板目录相对路径**，并且**不带后缀名**，例如 ：\r\n\t\r\n\tvar html = template('news/list', {hot: [...]});\r\n\tdocument.getElementById('list').innerHTML = html;\r\n\r\n##\t编译演示项目\r\n\r\n源码包中 ./test 是一个演示项目，./test/tpl 是项目的模板目录，包含了若干模板。你可以通过这个演示项目快速了解 TmodJS 用法以及模板语法、模板加载方式。\r\n\r\n首先，使用 cd 命令切换到 TmodJS 目录后，你可以编译这个目录模板：\r\n\r\n\t$ tmod test/tpl\r\n\r\n编译完毕后你可以在浏览器中打开 [./test/index.html](./test/index.html) 查看如何加载模板。\r\n\r\n## 对外接口\r\n\r\n若想作为一个库调用（例如在基于 NodeJS 的自动化工具中），TmodJS 提供如下接口：\r\n\r\n\tvar TmodJS = require('tmod.js');\r\n\t\r\n\t// 模板目录\r\n\tvar path = './demo/templates';\r\n\t\r\n\t// 配置\r\n\tvar options = {\r\n\t\toutput: './build',\r\n\t\tcharset: 'utf-8',\r\n\t\tdebug: false\r\n\t};\r\n\t\r\n\t// 初始化 TmodJS\r\n\t// path {String}\t模板目录\r\n\t// options {Object} 选项\r\n\tTmodJS.init(path, options);\r\n\t\r\n\t// 编译模板\r\n\t// file {String} 参数可选，无则编译整个模板目录，否则编译指定的模板文件\r\n\t// recursion {Boolean} 若为 false 则不编译依赖的模板\r\n\tTmodJS.compile(file, recursion);\r\n\t\r\n\t// 监控模板修改\r\n\tTmodJS.watch();\r\n\t\r\n\t// 保存用户设置到模板目录 package.json 文件中\r\n\tTmodJS.saveUserConfig();\r\n\t\r\n\t// 监听编译过程的事件\r\n\t// 支持：change、load、compileError、combo\r\n\tTmodJS.on('compile', function (data) {});\r\n\t\r\n##\t配置\r\n\r\n配置最终会保存在模板目录的 package.json 文件中，可以对它直接修改。\r\n\r\n\t{\r\n        // 编译输出目录设置\r\n        output: './build',\r\n\r\n        // 模板使用的编码。（注意：非 utf-8 编码的模板缺乏测试）\r\n        charset: 'utf-8',\r\n\r\n        // 模板合并规则\r\n        // 注意：type 参数的值为 templatejs 才会生效\r\n        combo: ['*'],\r\n\r\n        // 定义模板采用哪种语法，可选：\r\n        // simple: 默认语法，易于读写。可参看语法文档\r\n        // native: 功能丰富，灵活多变。语法类似微型模板引擎 tmpl\r\n        syntax: 'simple',\r\n\r\n        // 自定义辅助方法路径\r\n        helpers: null,\r\n\r\n        // 是否输出为压缩的格式\r\n        minify: true,\r\n\r\n        // 是否内嵌异步加载插件（beta）\r\n        // 可以支持 template.async(path, function (render) {}) 方式异步载入模板\r\n        // 注意：type 参数是 templatejs 的时候才生效\r\n        async: false,\r\n\r\n        // 是否嵌入模板引擎，否则编译为不依赖引擎的纯 js 代码\r\n        // 通常来说，模板不多的情况下，编译为原生的 js 打包后体积更小，因为不必嵌入引擎\r\n        // 当模板很多的时候，内置模板引擎，模板使用字符串存储的方案会更能节省空间\r\n        engine: false,\r\n\r\n        // 输出的模块类型（不区分大小写），可选：\r\n        // templatejs:  模板目录将会打包后输出，可使用 script 标签直接引入，也支持 NodeJS/RequireJS/SeaJS。\r\n        // cmd:         这是一种兼容 RequireJS/SeaJS 的模块（类似 atc v1版本编译结果）\r\n        // amd:         支持 RequireJS 等流行加载器\r\n        // commonjs:    编译为 NodeJS 模块\r\n        type: 'templatejs'     \r\n\t}\r\n\t\r\n##\t常见问题\r\n\r\n**问**：TmodJS 需要部署到服务器中吗？\r\n\r\n**答**：不需要，这是本地工具，基于 NodeJS 编写是为了实现跨平台。\r\n\r\n**问**：如何将每个模板都编译成单独的 amd/cmd 模块输出？\r\n\r\n**答**：指定 type 参数即可，如``--type cmd``则可以让每个模板都支持 RequireJS/SeaJS 调用。\r\n\r\n**问**：如何将模板编译成 NodeJS 的模块？\r\n\r\n**答**：指定 type 参数即可，如``--type commonjs``。\r\n\r\n**问**：线上运行的模板报错了如何调试？\r\n\r\n**答**：开启 debug 模式编译，如``-d``，这样会输出调试版本，可以让你快速找到模板运行错误的语句以及数据。\r\n\r\n**问**：如何不压缩输出 js？\r\n\r\n**答**：编辑配置文件，设置``minify:false``。\r\n\r\n**问**：如何修改默认的输出目录？\r\n\r\n**答**：指定 output 参数即可，如``--output ../../build``。\r\n\r\n**问**：如何让模板访问全局变量？\r\n\r\n**答**：~~请参考：链接~~（待更新）。\r\n\r\n**问**：如何使用 js 原生语法作为模板语法？\r\n\r\n**答**：~~请参考：链接~~（待更新）。\r\n\r\n**问**：如何升级 atc 的项目？\r\n\r\n**答**：~~请参考：链接~~（待更新）。\r\n\r\n**问**：如何迁移原来写在页面中的 artTemplage 模板，改为 TmodJS 的方式？\r\n\r\n**答**：~~请参考：链接~~（待更新）。\r\n\r\n\r\n##\t更新日志\r\n\r\n###\tTmodJS v0.0.1\r\n\r\n这是一个革命性的版本！同时项目更名为 **TmodJS**，内部版本号收归到 0.0.1，这是一个新的开始，未来将稳步更新。\r\n\r\n*\t吸收了来自业务的一些建议，编译方案的大调整，内部进行无数次优化，编译后的代码更小。\r\n*\t编译后的脚本使用统一的接口：``template(path, data)`` 其中 path 相对于 template.js 所在目录\r\n*\t自动打包目录与子目录的模板\r\n*\t可选支持异步载入模板功能\r\n*\t可选嵌入完整模板引擎（使用字符串存储模板）\r\n*\t可选支持 RequireJS/SeaJS/NodeJS 模块\r\n*\t保存模板配置文件（方便多人协作中使用版本管理工具共享配置）\r\n*\t可选编译调试版本\r\n*\t编译后的函数体优化\r\n*\t错误处理优化\r\n*\t``compile(file)``接口可递归编译依赖\r\n*\t增加``saveUserConfig``接口保存用户设置\r\n*\t默认语法变更：默认使用简洁语法，取消``--define-syntax``，并使用新的界定符 ``{{``与``}}``。[模板语法参考](https://github.com/aui/tmodjs/wiki/模板语法)\r\n*\t取消``--clone-helpers``参数\r\n\r\n###\tatc v1.0.3\r\n\r\n*\t默认使用简洁语法，取消--define-syntax，增加--no-define-syntax参数恢复原生语法\r\n*\t增加-t, --type设置输出的模块类型，默认 CMD ，可选：CMD | AMD | CommonJS。让模板可以前后端共用\r\n*\t优化无逻辑语句的模板编译后的函数体积\r\n*\t因 Windows 批处理无法模拟 NodeJS 的高级特性，atc 不再包含 Windows 批处理脚本，若需要可用批处理调用 NodeJS\r\n*\t模板语法的界定符有变更，请参考：模板语法\r\n\r\n###\tatc v1.0.2\r\n\r\nNodeJS 版本：\r\n\r\n*\t增加``-o path``或``--output path``定义输出目录\r\n*\t修复``-d``或``--define-syntax``可能失效的问题\r\n*\t修改``-w``或``--watch``参数启动后的规则：只监控模板修改，而不再编译所有模板\r\n*\t增强调试特性：模板语法错误将在控制台输出调试源码，并停止进程\r\n\r\n###\tatc v1.0.1\r\n\r\nNodeJS 版本：\r\n\r\n*\t支持监控目录，即时编译\r\n*\t使用命令行传递参数\r\n*\t使用 npm 管理包\r\n*\t支持设置简洁语法\r\n\r\n###\tatc v1.0.0\r\n\r\n*\t支持前端模板按文件与目录组织，自动处理 include 依赖\r\n*\tNodeJS 与 Windows 批处理版本同时发布\r\n\r\n=========\r\n\r\n如果你也认同 TmodJS 的理念、它能让你在开发中体会到书写模板的快乐，那么我希望你也能参与到 TmodJS 这个开源项目中来，无论是贡献代码、完善文档（目前文档还比较笼统）或者撰写博文推广它等。\r\n\r\n特别感谢 [@TooBug](https://github.com/TooBug) 的建议，以及 NodeJS 代码迁移支持；还有 [@warmhug](https://github.com/warmhug) 同学在编译器雏形阶段的热心的测试与反馈，正是因为你们的支持 TmodJS 才能逐步健壮。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}