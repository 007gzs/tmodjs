<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="进击！前端模板工程化 : 基于 TmodJS 前端模板工程化解决方案" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>进击！前端模板工程化</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/aui/tmodjs">View on GitHub</a>

          <h1 id="project_title">进击！前端模板工程化</h1>
          <h2 id="project_tagline">基于 TmodJS 前端模板工程化解决方案</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/aui/tmodjs/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/aui/tmodjs/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="%E8%BF%9B%E5%87%BB%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%B7%A5%E7%A8%8B%E5%8C%96" class="anchor" href="#%E8%BF%9B%E5%87%BB%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="octicon octicon-link"></span></a>进击！前端模板工程化</h1>

<h6>
<a name="%E5%9F%BA%E4%BA%8E-tmodjs-%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" href="#%E5%9F%BA%E4%BA%8E-tmodjs-%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="octicon octicon-link"></span></a>基于 TmodJS 前端模板工程化解决方案</h6>

<h2>
<a name="%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF" class="anchor" href="#%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%9D%BF"><span class="octicon octicon-link"></span></a>前端模板</h2>

<p>早期，开发人员都是直接在 js 文件中采用最原始的方式直接拼接 HTML 字符串：</p>

<pre><code>var html = '';
for (var i = 0, users = data.users; i &lt; users.length; i ++) {
    html += '&lt;li&gt;&lt;a href="'
    + users[i].url
    + '"&gt;'
    + users[i].name
    + '&lt;/a&gt;&lt;/li&gt;';
}
//...
</code></pre>

<p>这种方式刚开始在一两个简单的页面中还是比较灵活的，但弊端也十分明显：UI 与逻辑代码混杂在一起，阅读起来会非常吃力。一旦随着业务复杂起来，或者多人维护的情况下，几乎会失控。</p>

<p>受 jquery 作者的 tmpl 模板引擎影响，从 09 年开始到现在，前端模板引擎出现了百花齐放的局面，涌现出一大批行色各异的引擎，几乎每个前端工程中都使用了模板引擎。一条前端模板类似这样：</p>

<pre><code>&lt;script id="user_tmpl" type="text/html"&gt;
{{each users as value}}
    &lt;li&gt;
        &lt;a href="{{value.url}}"&gt;{{value.name}}&lt;/a&gt;
    &lt;/li&gt;
{{/each}}
&lt;/script&gt;
</code></pre>

<p>它使用一个特殊的<code>&lt;script type="text/html"&gt;&lt;/script&gt;</code>标签来存放模板（由于浏览器不支持这种类型的声明，它存放的代码不会当作 js 运行，代码也不会被显示出来）。使用模板引擎渲染模板的示例：</p>

<pre><code>var html = tmpl('user_tmpl', data);
document.getElementById('content').innerHTML = html;
</code></pre>

<p><a href="http://aui.github.io/artTemplate/demo/simple-syntax/basic.html">在线示例</a></p>

<p>通过前端模板引擎将 UI 分离后，模板的书写与修改就变得简单多了，也提升了可维护性。但是，随着这种方式规模化后其弊端也随之而来。</p>

<h2>
<a name="%E6%A8%A1%E6%9D%BF%E5%86%85%E5%B5%8C%E7%9A%84%E5%BC%8A%E7%AB%AF" class="anchor" href="#%E6%A8%A1%E6%9D%BF%E5%86%85%E5%B5%8C%E7%9A%84%E5%BC%8A%E7%AB%AF"><span class="octicon octicon-link"></span></a>模板内嵌的弊端</h2>

<h3>
<a name="%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95" class="anchor" href="#%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95"><span class="octicon octicon-link"></span></a>开发调试</h3>

<p>每次修改前端模板需要改动页面的代码，如果不是纯静态页面，无法使用类似 fiddler 的工具将页面映射到本地进行开发，开发调试依赖只能服务端环境，成本过高。</p>

<h3>
<a name="%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90" class="anchor" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E9%9B%86%E6%88%90"><span class="octicon octicon-link"></span></a>自动化集成</h3>

<p>在现代 web 前端工程体系中，几乎每一个环节都拥有相应的优化工具，这些几乎都被 grunt 这个自动构建工具连接起来。但是前端模板若内嵌到页面中，复杂度会比较高，现有的工具难以介入进行优化（例如模板压缩）。</p>

<h3>
<a name="%E6%A8%A1%E5%9D%97%E5%8C%96" class="anchor" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="octicon octicon-link"></span></a>模块化</h3>

<p>随着项目规模增大，必然会产生很多可以公用的模板，尤其是多页面共享模板的时候，处理内嵌的公用模板成了一个棘手的问题。</p>

<h2>
<a name="%E7%8E%B0%E6%9C%89%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%A4%96%E7%BD%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" href="#%E7%8E%B0%E6%9C%89%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%A4%96%E7%BD%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="octicon octicon-link"></span></a>现有的模板外置解决方案</h2>

<p>目前越来越的项目已经将模板从页面中迁移出来，目前主要有两种方式：</p>

<h3>
<a name="ajax-%E6%8B%89%E5%8F%96%E6%96%B9%E6%A1%88" class="anchor" href="#ajax-%E6%8B%89%E5%8F%96%E6%96%B9%E6%A1%88"><span class="octicon octicon-link"></span></a>Ajax 拉取方案</h3>

<p>通过 Ajax 加载远程模板，然后再使用模板引擎解析。这种方式的好处就是模板可以按文件存放，书写起来也是十分便利，但弊端相当明显：</p>

<ol>
<li> 无法跨域部署。这是由浏览器同源策略限制的，导致模板无法部署到 CDN 网络。</li>
<li> 复杂度比较高，难以接入主流的自动化部署、优化工具。</li>
</ol><h3>
<a name="%E5%9C%A8-js-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%98%E6%94%BE%E6%A8%A1%E6%9D%BF" class="anchor" href="#%E5%9C%A8-js-%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%98%E6%94%BE%E6%A8%A1%E6%9D%BF"><span class="octicon octicon-link"></span></a>在 JS 文件中存放模板</h3>

<p>为避免上述加载模板方案无法跨域的致命缺陷，模板存放在 js 文件中又成了最佳实践方式，但是这种情况下需要对回车符进行转义，对书写不友好，严重影响开发效率。例如：</p>

<pre><code>var user_tmpl =
'{{each users as value}}\
    &lt;li&gt;\
        &lt;a href="{{value.url}}"&gt;{{value.name}}&lt;/a&gt;\
    &lt;/li&gt;\
{{/each}}';
</code></pre>

<p>或者：</p>

<pre><code>var user_tmpl =
 '{{each users as value}}'
+   '&lt;li&gt;'
+       '&lt;a href="{{value.url}}"&gt;{{value.name}}&lt;/a&gt;'
+   '&lt;/li&gt;'
+'{{/each}}';
</code></pre>

<h2>
<a name="%E6%A8%A1%E6%9D%BF%E7%BB%84%E7%BB%87%E6%96%B9%E6%A1%88%E4%BC%98%E5%8A%A3%E6%80%BB%E7%BB%93" class="anchor" href="#%E6%A8%A1%E6%9D%BF%E7%BB%84%E7%BB%87%E6%96%B9%E6%A1%88%E4%BC%98%E5%8A%A3%E6%80%BB%E7%BB%93"><span class="octicon octicon-link"></span></a>模板组织方案优劣总结</h2>

<table>
<thead><tr>
<th>存放方式</th>
<th>开发效率</th>
<th>优化空间</th>
<th>本地调试</th>
<th>代码复用</th>
<th>团队协作</th>
</tr></thead>
<tbody>
<tr>
<td>内嵌业务页中</td>
<td>✓</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
<td>✗</td>
</tr>
<tr>
<td>Ajax 远程加载</td>
<td>✓</td>
<td>✗</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>嵌入 js 文件</td>
<td>✗</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
</tbody>
</table><p>总结：方便优化的模式不利于开发；利于开发的模式不利于优化。</p>

<h2>
<a name="%E7%90%86%E6%83%B3%E6%A8%A1%E5%BC%8F" class="anchor" href="#%E7%90%86%E6%83%B3%E6%A8%A1%E5%BC%8F"><span class="octicon octicon-link"></span></a>理想模式</h2>

<p>看下服务端模板技术是如何做的：</p>

<p>一、<strong>模板按文件与目录组织模板</strong></p>

<pre><code>template('tpl/home/main', data)
</code></pre>

<p>二、<strong>模板使用 include 语句完成复用</strong></p>

<pre><code>{{include '../public/header'}}
</code></pre>

<p>这一切看起来很美，前端是否也可以采用这样的模式？但是现实告诉我们，这是一个艰巨的任务。</p>

<h2>
<a name="%E7%8E%B0%E5%AE%9E%E9%9A%BE%E9%A2%98" class="anchor" href="#%E7%8E%B0%E5%AE%9E%E9%9A%BE%E9%A2%98"><span class="octicon octicon-link"></span></a>现实难题</h2>

<ul>
<li>浏览器对文本加载会有跨域限制</li>
<li>浏览器同步加载会引起界面卡顿</li>
<li>加载大量的模板文件会带来 http 资源消耗问题</li>
</ul><h2>
<a name="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" class="anchor" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="octicon octicon-link"></span></a>解决方案</h2>

<p>针对上述问题，我开发了一个叫 TmodJS 的模板预编译工具。以下是它的简介：</p>

<blockquote>
<p>TmodJS（原名 atc）是一个简单易用的前端模板预编译工具。它通过预编译技术让前端模板突破浏览器限制，实现后端模板一样的同步“文件”加载能力。它采用目录来组织维护前端模板，从而让前端模板实现工程化管理，最终保证前端模板在复杂单页 web 应用下的可维护性。同时预编译输出的代码经过多层优化，能够在最大程度节省客户端资源消耗。</p>
</blockquote>

<p>为了实现上述“理想模式”，它采用三种方案来实现：</p>

<h3>
<a name="1%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA" class="anchor" href="#1%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA"><span class="octicon octicon-link"></span></a>1.本地构建</h3>

<p>模板编写完成后，通过一个本地工具将模板编译成浏览器可执行的代码——js，这样就可以用脚本的方式来加载模板，不必受浏览器的同源策略限制，模板可以部署到任意 CDN，而无需处理跨域问题。</p>

<p>工具内部采用模板引擎——<a href="https://github.com/aui/artTemplate">artTemplate</a>完成模板编译，输出 js 文件。<a href="https://github.com/aui/artTemplate">artTemplate</a>是我另外一个开源项目，它支持预编译，编译后的代码可以无需引擎运行。</p>

<h3>
<a name="2%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6" class="anchor" href="#2%E7%A7%8D%E5%AD%90%E6%96%87%E4%BB%B6"><span class="octicon octicon-link"></span></a>2.种子文件</h3>

<p>为了实现<code>template(path, data)</code>这种同步接口，TmodJS 会不断的更新一个名为 template.js 的种子文件，这个文件合并了公用方法与编译后的模板，项目只需要引用这个文件就可以按路径同步的方式调用模板。例如：</p>

<pre><code>var tpl = template('home/index');
var html = tpl(data);
document.getElementById('content').innerHTML = html;
</code></pre>

<h3>
<a name="3%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95" class="anchor" href="#3%E6%A8%A1%E6%9D%BF%E7%9B%AE%E5%BD%95"><span class="octicon octicon-link"></span></a>3.模板目录</h3>

<p>为了保证工具能够管理模板，前端模板不再内嵌到页面中，而是使用专门的目录进行组织维护；使用路径作为模板的 ID，这样与源文件保持对应关系——这样好处就是极大的增加了可维护性。例如：页面头部底部的公用模板可以放在<code>tpl/public</code>目录下，首屏的模板可以放在<code>tpl/home</code>下面。</p>

<h2>
<a name="%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96" class="anchor" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="octicon octicon-link"></span></a>模板与工程化</h2>

<p>TmodJS 采用了自动编译机制，一经启动后无需人工干预，每次模板创建与更新都会自动编译，直到正式上线都无需对代码进行任何修改，整个过程简单自然。</p>

<p>与其说 TmodJS 是一个模板预编译器，不如说它是一个前端模板工程管理工具，它能做到：</p>

<h3>
<a name="%E6%A8%A1%E6%9D%BF%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6" class="anchor" href="#%E6%A8%A1%E6%9D%BF%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="octicon octicon-link"></span></a>模板压缩与合并</h3>

<p>TmodJS 编译之前会压缩掉模板的空白字符，编译为 js 后又会进行一次压缩，此时输出的 js 甚至会比原始模板更小（最高可减少一半的体积）。</p>

<p>在默认设置下，TmodJS 会将模板目录所有模板编译后再进行压缩与合并，输出后的 template.js 称之为模板包（内部名称叫 TemplateJS 格式）这种打包的方式非常适合移动端单页 WebApp，输出后的模板包可直接可作为开发阶段与线上运行的文件，适合中小型项目。</p>

<p><a href="http://microtrend.cdc.tencent.com/tpl/dist/template.js">查看编译后的模板示例</a></p>

<h3>
<a name="%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" class="anchor" href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="octicon octicon-link"></span></a>依赖管理</h3>

<p>当然，将所有前端模板都打包在一个文件中不一定适合每一个项目，因为很多大型项目需要更细致的优化，所以 TmodJS 还可以选择输出单个的 js 文件，这样这些模板脚本可以交给外部工具进行按需打包合并（例如 grunt）。</p>

<p>除此之外，如果编译为 AMD、CMD、CommonJS 类型的的模块，模板内部的<code>include</code>语句会编译成<code>requier('xxx/xxx')</code>形式声明依赖，接入 RequireJS 优化工具 r.js 或者 SeaJS 的 spm 可以完成精准依赖合并。</p>

<h3>
<a name="%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95" class="anchor" href="#%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95"><span class="octicon octicon-link"></span></a>本地调试</h3>

<p>模板最终对应的是 js 文件，所以可以使用 Fiddler 将线上模板映射到本地进行开发调试。如果线上模板报错，TmodJS 开启<code>debug</code>模式后可以直接找到出错的模板以及所在行号，例如：</p>

<pre><code>Template Error

&lt;id&gt;
public/header

&lt;name&gt;
Render Error

&lt;message&gt;
Cannot read property '0' of undefined

&lt;line&gt;
5

&lt;source&gt;
{{users[0].name}}
</code></pre>

<h3>
<a name="%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%85%8D%E5%90%88" class="anchor" href="#%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E9%85%8D%E5%90%88"><span class="octicon octicon-link"></span></a>与第三方自动化构建工具配合</h3>

<p>目前支持 grunt 与 gulp 这两种自动化构建工具。</p>

<h3>
<a name="%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%85%B1%E4%BA%AB" class="anchor" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E6%A8%A1%E6%9D%BF%E5%85%B1%E4%BA%AB"><span class="octicon octicon-link"></span></a>前后端模板共享</h3>

<p>TmodJS 与 artTemplate 模板引擎使用同样的模板语法，而 artTemplate 提供了 NodeJS 版本，可以直接读取 TmodJS 的模板目录，这意味着可以轻松的做到前后端模板共享，技术方案自由切换。</p>

<h3>
<a name="%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C" class="anchor" href="#%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C"><span class="octicon octicon-link"></span></a>多人协作</h3>

<ul>
<li>配置可共享：TmodJS 配置保存在模板目录的 package.json 文件中</li>
<li>强制编码规范：编译后的代码运行在沙箱中，从而避免模板访问外部对象导致依赖问题；模板需要的公用方法、变量需配置后才能使用</li>
</ul><h2>
<a name="%E5%85%B3%E4%BA%8E-tmodjs" class="anchor" href="#%E5%85%B3%E4%BA%8E-tmodjs"><span class="octicon octicon-link"></span></a>关于 TmodJS</h2>

<p>起源于腾讯内部公用组件平台的开源项目（atc），历经多次版本迭代，目前已经有多个项目在使用。</p>

<p><a href="https://github.com/aui/tmodjs">https://github.com/aui/tmodjs</a></p>

<h3>
<a name="%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE" class="anchor" href="#%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE"><span class="octicon octicon-link"></span></a>服务项目</h3>

<ul>
<li>  QQ空间</li>
<li>  腾讯视频</li>
<li>  爱奇艺</li>
<li>  爱拍原创</li>
<li>  Spa（迅雷）</li>
<li>  MicroTrend（腾讯）</li>
<li>  Tracker（腾讯）</li>
<li>  UR（腾讯）</li>
<li>  ……</li>
</ul><h3>
<a name="%E6%84%BF%E6%99%AF" class="anchor" href="#%E6%84%BF%E6%99%AF"><span class="octicon octicon-link"></span></a>愿景</h3>

<p>希望 TmodJS 能成为每个前端开发者必备的利器！</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">进击！前端模板工程化 maintained by <a href="https://github.com/aui">aui</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
